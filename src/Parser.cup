import java_cup.runtime.*;
import java.util.ArrayList;

scan with {: return lexer.next_token(); :};
parser code {:
  private boolean debug = true;
  public boolean  debug()         {return debug;}
  public void     debug(boolean b){debug = b;}
  static class Node {
    public ArrayList<Node> children;
    private static int globalCounter = 0;
    public int counter;
    private Object value;
    public Node(Object value){
      Node.globalCounter += 1;
      this.counter = Node.globalCounter;
      this.value = value;
      this.children = new ArrayList<Node>();
    }
    public void addChild(Node n){ children.add(n); }
    public String toString(){
      String ret = "";
      ret += String.format("%d [label=\"%s\"];\n",
                            counter, value.toString());
      for(Node n: children){
        ret += String.format("%d -> %d;\n", this.counter, n.counter);
        ret += n.toString();
      }
      return ret;
    }
  }
  private Lexer lexer;
  public Parser(Lexer lex) {
    super(lex);
    lexer = lex;
  }
  public void syntax_error(Symbol current_token) { report_error(
         "Syntax error at line " + (current_token.left+1) + ", column "
  + current_token.right, null );
  } 
:};

/* Terminals (Returned By Lexer). -----------------------*/

// Math Operators

terminal SYM_PLUS, SYM_MINUS, SYM_STAR, SYM_DIV, SYM_BSLASH, SYM_EQUAL, SYM_LARROW, SYM_RARROW, SYM_CARET, SYM_PRCNT, LEQ, GEQ;

// Logical Operators

terminal SYM_OR, SYM_AND, EQEQ, NOTEQ, CONCAT;

// Punctuation 

terminal SYM_EXCLPNT, SYM_HASH, SYM_DOLLAR, SYM_AMP, SYM_LPAREN, SYM_RPAREN, SYM_COMMA, SYM_PERIOD, SYM_COLON, SYM_SEMI, SYM_QSTN, SYM_AT, SYM_LSQR, SYM_RSQR, SYM_LCRL, SYM_RCRL, SYM_BLASH, SYM_USCORE, SYM_GRAVE, SYM_TILDE, SYM_PIPE;

// TYPES 

terminal MAIN, DICT, SEQ, CHAR, BOOL, INT, RAT, FLOAT;


// Flow Control

terminal IFEL, THEN, ELSE, ELIF, WHILE, FORALL, DO, RETURN;

// Literals

terminal IDENT, CHAR_LITERAL, INT_LITERAL, STRING_LITERAL, BOOL_LITERAL;

//OTHER

terminal TOP, IN, LEN, TDEF, FDEF, ALIAS, VOID, READ, PRINT, FI, OD, LET;


/* Non terminals --------------------------------------*/

nonterminal statements, statement, top_level; 

nonterminal type_name, let_bind, full_exp, simple_exp, operator, literal;

/* Precedences ----------------------*/

precedence left SYM_PLUS, SYM_MINUS, SYM_AND, SYM_OR, SYM_LPAREN, SYM_RPAREN, SYM_LSQR , SYM_RSQR, SYM_PRCNT;
precedence left SYM_STAR, SYM_DIV;
precedence right SYM_CARET;
precedence nonassoc NOTEQ, GEQ, LEQ, EQEQ, SYM_LARROW, SYM_RARROW, SYM_EQUAL, CONCAT; 



/* The grammar ----------------------*/

top_level ::= statements:ss {:
                if(debug()) System.out.println((Node)ss);
              :}
            ;

statements ::= statements:ss statement:s {:
                  Node n = (Node)ss;
                  n.addChild((Node)s);
                  RESULT = n;
               :}
             | /* empty */ {:
                  RESULT = new Node("Statements");
               :}
             ;

statement ::=  simple_exp:s SYM_SEMI {:
                RESULT = Node(s);
              :}
            ;

type_name ::= CHAR:i {: RESULT = new Node(i); :}
        | DICT:i {: RESULT = new Node(i); :}
        | SEQ:i {: RESULT = new Node(i); :}
        | BOOL:i {: RESULT = new Node(i); :}
        | INT:i {: RESULT = new Node(i); :}
        | RAT:i {: RESULT = new Node(i); :}
        | FLOAT:i {: RESULT = new Node(i); :}
        ;


simple_exp ::= type_name:i {::}
          | IDENT:i {::}
          | simple_exp:e1 operator:o simple_exp:e2 {::}
          | SYM_LPAREN simple_exp:e SYM_RPAREN
          | literal
          ;

literal ::= CHAR_LITERAL
           | STRING_LITERAL 
           | unsigned_int
           | signed_int
           | float
           | rational
           | BOOL_LITERAL
           | dictionary
           | sequence 
           ;

operator ::= SYM_PLUS       {: RESULT = new Node("+"); :}
           | SYM_MINUS      {: RESULT = new Node("-"); :}
           | SYM_STAR       {: RESULT = new Node("*"); :}
           | SYM_DIV        {: RESULT = new Node("/"); :}
           | SYM_LARROW     {: RESULT = new Node("<"); :}
           | SYM_EQUAL      {: RESULT = new Node("="); :}
           | SYM_RARROW     {: RESULT = new Node(">"); :}
           | SYM_AND        {: RESULT = new Node("&&"); :}
           | SYM_OR         {: RESULT = new Node("||"); :}
           | EQEQ           {: RESULT = new Node("=="); :}
           | NOTEQ          {: RESULT = new Node("!="); :}
           | LEQ            {: RESULT = new Node("<="); :}
           | GEQ            {: RESULT = new Node(">="); :}
           | SYM_CARET      {: RESULT = new Node("^"); :}
           | SYM_PRCNT      {: RESULT = new Node("%"); :}
           | SYM_CONCAT     {: RESULT = new Node("::"); :}
           ;

signed_int ::= SYM_MINUS:m INT_LITERAL;

unsigned_int ::= INT_LITERAL;

float ::= signed_int:i1 SYM_PERIOD:p unsigned_int:i2
            | unsigned_int:i1 SYM_PERIOD:p unsigned_int:i2
            ;

rational ::= signed_int:i1 SYM_USCORE:u unsigned_int:i2 SYM_DIV:d unsigned_int:i3
            | unsigned_int:i1 SYM_USCORE:u unsigned_int:i2 SYM_DIV:d unsigned_int:i3
            ;

